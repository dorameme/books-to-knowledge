# 콘보이 vs HOL 차단
둘 다 “앞에서 막혀 뒤가 못 움직이는 현상”이라는 점에서는 비슷하지만,    
**등장하는 계층과 원인 구조가 완전히 다르다**.       
그래서 개념적으로 같은 현상처럼 보이지만, 실제로는 **다른 문제**이다.

---

# **1. 콘보이(Convoy effect)**

### **등장 위치:** 운영체제(OS) 프로세스/스레드 스케줄링

### **핵심 원인:** 하나의 **느린 프로세스가 CPU를 오래 점유**하면, 뒤의 빠른 프로세스들이 ‘컨보이(행렬)’처럼 줄줄이 지연됨

### **구조**

* FCFS(First Come First Served) 스케줄러에서 자주 발생
* 한 프로세스가 I/O-bound → CPU를 거의 안 씀 → 자주 큐로 복귀
* 그 뒤에 CPU-bound 프로세스들이 몰려서 계속 대기
* 결국 전체 처리량 감소

### **예:**

```
P1 (느림) → P2 (빠름) → P3(빠름)
P1이 오래 붙잡고 있으면 뒤가 못 움직임
```

---

# **2. HOL 블록킹(Head-of-line blocking)**

### **등장 위치:** 네트워크/큐잉 시스템

### **핵심 원인:** 큐의 **맨 앞 패킷/요청이 처리되지 않아** 뒤의 요청들도 멈춤

### **구조**

* 패킷 스위치에서 앞 패킷이 막혀 뒤에 있는 다른 목적지 패킷도 지연
* HTTP/1.1 keep-alive에서도 발생(한 요청이 느리면 뒤 요청도 막힘)

### **예:**

```
[패킷 A (막힘)] [패킷 B(빠름)] [패킷 C(빠름)]
A가 처리 안 되면 B, C도 못 감
```

---

# **3. 둘의 본질적 차이**

| 구분        | 콘보이              | HOL 블록킹                     |
| --------- | ---------------- | --------------------------- |
| 발생 영역     | 운영체제 스케줄링        | 네트워크·큐                      |
| 앞에서 막는 주체 | 느린 프로세스          | 처리되지 않는 첫 번째 요청/패킷          |
| 병목 원인     | CPU/I/O 점유 시간 차이 | 큐의 순차 처리 구조                 |
| 해결책       | 스케줄러 변경, 우선순위 부여 | 병렬 처리, 멀티 스트림(HTTP/2), 큐 분리 |

---

# **4. 핵심 결론**

### **둘 다 “앞에 있는 게 느려서 뒤가 막힘”이라는 패턴은 같지만, 완전히 다른 계층에서 발생하는 별개의 문제이다.**

* 콘보이는 OS 레벨
* HOL 블록킹은 네트워크/큐 레벨
* 원인, 해결책, 시스템 구조가 전혀 다르다

그래서 비슷해 보여도 **개념적으로 동일한 문제라고 보면 안 된다.**

필요하면 둘을 한 문장으로 비교해서 정리해 줄까?
