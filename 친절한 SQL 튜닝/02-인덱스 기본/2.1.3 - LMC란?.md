아, 이제 알겠다. 말하는 LMC는 **B-Tree 또는 B+Tree에서 Leftmost Child**를 의미하는 거군.

질문은 **“Leftmost Child(LMC) 노드에는 왜 키 값이 없는가?”**라는 거네. 차근차근 설명할게.

---

# 1. B-Tree / B+Tree 구조 복습

* **노드 구성**

  * Internal Node (중간 노드): 키 값과 자식 포인터를 가짐
  * Leaf Node (리프 노드): 실제 데이터 레코드 또는 포인터를 가짐
* **포인터 구조**

  * Internal Node: `[P0 | K1 | P1 | K2 | P2 | ... | Kn | Pn]`

    * Pi = 자식 노드 포인터
    * Ki = 키 값

---

# 2. Leftmost Child(LMC)

* Internal Node의 **가장 왼쪽 포인터(P0)**
* **키 값이 없음**
* 이유:

  1. **왼쪽 포인터는 해당 노드보다 작은 모든 값 범위를 가리키기 때문**

     * 예를 들어, `[P0 | K1 | P1 | K2 | P2]`라면

       * P0 → (-∞ ~ K1) 범위
       * P1 → (K1 ~ K2)
       * P2 → (K2 ~ +∞)
  2. 키 값이 필요 없는 이유:

     * P0는 비교 기준이 되는 키(K1, K2, ...)보다 항상 작은 값을 포함
     * 따라서 왼쪽 포인터 자체에는 특정 키가 필요 없음
  3. 구조상 다른 자식 포인터와 균일하게 포인터만 존재

     * Internal Node에서는 “범위를 나누는 키”가 포인터 사이에만 위치함

---

# 3. 그림 예시

```
         [ K1 | K2 ]
        /    |    \
     P0      P1     P2
```

* P0 = Leftmost Child (LMC)
* P0 범위 = (-∞, K1)
* P0에는 키 값이 없음 → 비교 기준 K1이 이미 P0 오른쪽에 있기 때문
* P1 범위 = [K1, K2)
* P2 범위 = [K2, ∞)

즉 **LMC 자체는 범위를 가리키는 포인터 역할만 하고, Key 값은 필요하지 않음**

---

# 4. 요약

1. **LMC는 Internal Node의 가장 왼쪽 포인터**
2. **키 값이 없는 이유**

   * 이미 오른쪽에 있는 키(K1, K2 등)가 범위 비교 기준을 제공
   * LMC는 그보다 작은 모든 값 범위를 포인터로 가리키면 충분
3. 따라서 B-Tree / B+Tree 설계상 자연스럽게 **왼쪽 포인터에는 Key가 없음**




LMC(Leftmost Child)는 Internal Node에서 “범위 검색의 시작점” 역할을 한다.

Internal Node에서 Key는 포인터 사이의 경계를 의미하고, 왼쪽 가장 첫 포인터(LMC)는 그 노드에서 검색을 시작하는 출발점이 된다.

즉:

Internal Node에서 값을 찾을 때
Key와 비교하여 어느 자식 포인터로 내려갈지 결정
가장 왼쪽 값보다 작은 값이면 LMC(P0)로 내려감

LMC가 없으면

“가장 작은 값”부터 탐색을 시작할 기준이 없어짐
검색이 어려워지고, Internal Node 설계가 불완전해짐
