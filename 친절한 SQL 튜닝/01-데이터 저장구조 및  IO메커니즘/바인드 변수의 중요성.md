
#  왜 바인드 변수를 쓰면 하드 파싱을 줄일까?

바인드 변수를 쓰면 **SQL 문장 자체는 그대로 유지되고, 값만 달라지기 때문**에 하드 파싱을 줄일 수 있다.            
핵심은 **DB가 캐싱하는 건 ‘SQL 문장의 구조’이지, 값이 아니다**라는 점이다.


### ■ 1. DB가 캐싱하는 것 = SQL 텍스트(문장 구조)

DB는 SQL을 받으면 이렇게 한다:

1. **SQL 텍스트가 이전에 본 것인지 검색**
2. 본 적 없으면 하드 파싱 → 실행 계획 생성 → 캐시에 저장
3. 본 적 있으면 캐싱된 실행 계획 재사용 (소프트 파싱)

여기서 중요한 포인트:

* DB는 SQL 문장의 **텍스트가 1글자라도 다르면** *다른 문장*으로 취급함.

예시:

```sql
SELECT * FROM users WHERE id = 10;
SELECT * FROM users WHERE id = 11;
```

텍스트가 다르므로 DB는 완전히 다른 SQL로 보고 **두 번 다 하드 파싱**함.

---

#  바인드 변수가 왜 답이 되는가?

바인드 변수를 쓰면 SQL 텍스트가 이렇게 변한다:

```sql
SELECT * FROM users WHERE id = :id;
```

값이 10이든 11이든 SQL 문장은 **완전히 동일한 문자열**이다.

→ DB 입장에서는 “아 이 SQL 전에 봤던 그거네” 하고
→ **캐싱된 실행 계획을 그대로 재사용(소프트 파싱)**

즉, 캐싱의 조건은 **SQL 텍스트가 같냐?** 인데
바인드 변수는 이것을 만족시켜준다.

---

#  “근데 값은 계속 바뀌는데 어떻게 공유해?”

DB가 캐싱하는 건 **값이 아니라 SQL 구조**라서 아무 문제 없음.

바인드 변수는 파싱 단계가 아니라 **실행 단계에서 값이 대입됨**.

흐름:

### ✔ 파싱 단계

```
SELECT * FROM users WHERE id = :id
```

→ "이 구조는 전에 봤어. 실행 계획 재사용!"

### ✔ 실행 단계

```
바인드 변수 id = 10 대입
→ 실행
```

다음 요청:

```
바인드 변수 id = 11 대입
→ 실행
```

SQL 구조 = 그대로 → 실행 계획 공유
값 = 실행할 때만 대입 → 캐시 영향 없음

---

#  비유로 쉽게 설명

### ** 레시피를 캐싱한다고 생각하면 됨**

* 레시피(SQL 구조)는 그대로
* 라면에 넣는 재료(바인드 값)는 매번 바뀜

‘레시피 캐싱’을 위해 필요한 건 **추가된 재료가 아니라 레시피 일치 여부**임.

---

#  정리

| 방식     | SQL 텍스트 | 캐싱 가능? | 파싱 비용      |
| ------ | ------- | ------ | ---------- |
| 리터럴 값  | 매번 다름   | 못함     | 하드 파싱 반복   |
| 바인드 변수 | 항상 동일   | 가능     | 소프트 파싱(빠름) |

---

#  한 문장으로 요약

**바인드 변수는 값이 아니라 SQL 문장의 ‘형태’를 고정시키기 때문에 실행 계획을 공유할 수 있고, 그 결과 하드 파싱이 줄어든다.**
