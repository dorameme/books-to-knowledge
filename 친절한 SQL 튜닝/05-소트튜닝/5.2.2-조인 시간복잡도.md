

## 비용 계산의 기본 전제

- M: 외부(Outer) 테이블의 행 수
- N: 내부(Inner) 테이블의 행 수
- 비용 = **디스크 I/O 횟수 + CPU 연산 횟수**

## 1. Hash Join: O(M + N)

### 동작 방식
```
1단계: Build Phase (M)
- 작은 테이블(M)을 읽어서 메모리에 해시 테이블 생성
- M개 행을 모두 읽음 → M번의 I/O

2단계: Probe Phase (N)
- 큰 테이블(N)을 읽으면서 해시 테이블 탐색
- N개 행을 모두 읽음 → N번의 I/O
- 해시 탐색은 O(1)

총 비용: M + N
```

### 예시
```
상품 테이블: 1,000건 (M)
계약 테이블: 100,000건 (N)

1. 상품 1,000건 읽어서 해시 테이블 생성
2. 계약 100,000건 읽으면서 해시 매칭
총: 1,000 + 100,000 = 101,000번의 작업
```

### 언제 유리한가?
- 양쪽 테이블이 모두 클 때
- 인덱스가 없을 때
- 조인 결과가 많을 때 (대부분 매칭될 때)

---

## 2. Nested Loop Join: O(M × log N)

### 동작 방식
```
외부 테이블의 각 행마다:
  내부 테이블에서 매칭되는 행 찾기 (인덱스 사용)
  
1단계: 외부 테이블 스캔 (M)
- M개 행을 순차적으로 읽음

2단계: 내부 테이블 인덱스 탐색 (M × log N)
- M번 반복
- 각 반복마다 B-Tree 인덱스 탐색: log N

총 비용: M + M × log N = M × (1 + log N) ≈ M × log N
```

### 예시
```
계약 테이블 (외부): 100건 (M)
상품 테이블 (내부): 1,000건 (N), 인덱스 있음

1. 계약 100건 읽기: 100번
2. 각 계약마다 상품 인덱스 탐색:
   - 100번 × log₂(1,000) ≈ 100 × 10 = 1,000번
총: 100 + 1,000 = 1,100번의 작업

만약 인덱스가 없다면:
- 100번 × 1,000번 = 100,000번 (O(M × N))
```

### 언제 유리한가?
- 외부 테이블이 **매우 작을 때** (M이 작음)
- 내부 테이블에 **인덱스가 있을 때** (log N)
- 조인 결과가 적을 때

---

## 3. Sort Merge Join: O(M log M + N log N)

### 동작 방식
```
1단계: Sort Phase
- 외부 테이블 정렬: M × log M
- 내부 테이블 정렬: N × log N

2단계: Merge Phase
- 정렬된 두 테이블을 순차적으로 병합: M + N

총 비용: M log M + N log N + M + N
       ≈ M log M + N log N (정렬 비용이 지배적)
```

### 예시
```
계약 테이블: 10,000건 (M)
상품 테이블: 1,000건 (N)

1. 계약 정렬: 10,000 × log₂(10,000) ≈ 10,000 × 13 = 130,000
2. 상품 정렬: 1,000 × log₂(1,000) ≈ 1,000 × 10 = 10,000
3. 병합: 10,000 + 1,000 = 11,000
총: 130,000 + 10,000 + 11,000 = 151,000번

만약 이미 정렬되어 있다면:
- 병합만: 10,000 + 1,000 = 11,000번만 필요!
```

### 언제 유리한가?
- 이미 정렬되어 있을 때 (정렬 비용 0)
- 양쪽 테이블이 비슷한 크기일 때
- 조인 결과가 많을 때
- 등가 조인(=)이 아닐 때도 사용 가능

---

## 실전 비교표

### 시나리오 1: 작은 테이블 × 큰 테이블

```
외부: 100건, 내부: 100,000건 (인덱스 있음)
```

| 조인 방식 | 계산 | 비용 | 순위 |
|---------|------|-----|-----|
| **Nested Loop** | 100 × log(100,000) ≈ 100 × 17 | **1,700** | 1위 ✓ |
| **Hash Join** | 100 + 100,000 | 100,100 | 2위 |
| **Sort Merge** | 100×7 + 100,000×17 | 1,700,700 | 3위 |

### 시나리오 2: 큰 테이블 × 큰 테이블

```
외부: 50,000건, 내부: 100,000건
```

| 조인 방식 | 계산 | 비용 | 순위 |
|---------|------|-----|-----|
| **Hash Join** | 50,000 + 100,000 | **150,000** | 1위 ✓ |
| **Nested Loop** | 50,000 × log(100,000) ≈ 50,000 × 17 | 850,000 | 3위 |
| **Sort Merge** | 50,000×16 + 100,000×17 | 2,500,000 | 2위 |

### 시나리오 3: 이미 정렬된 테이블

```
외부: 10,000건 (정렬됨), 내부: 10,000건 (정렬됨)
```

| 조인 방식 | 계산 | 비용 | 순위 |
|---------|------|-----|-----|
| **Sort Merge** | 0 + 0 + (10,000 + 10,000) | **20,000** | 1위 ✓ |
| **Hash Join** | 10,000 + 10,000 | 20,000 | 1위 ✓ |
| **Nested Loop** | 10,000 × log(10,000) | 133,000 | 2위 |

---

## 인덱스의 중요성

### Nested Loop에서 인덱스 유무

```
M = 100, N = 10,000

인덱스 있음: O(M × log N)
- 100 × log(10,000) = 100 × 13 = 1,300

인덱스 없음: O(M × N)
- 100 × 10,000 = 1,000,000 (770배 차이!)
```

### 인덱스가 있어도 NL이 불리한 경우

```
M = 10,000, N = 100,000

인덱스 있음:
- 10,000 × log(100,000) = 10,000 × 17 = 170,000

Hash Join:
- 10,000 + 100,000 = 110,000 (더 빠름!)
```

---

## 옵티마이저의 선택 기준

```sql
-- 옵티마이저가 고려하는 것들
1. 테이블 크기 (M, N)
2. 인덱스 존재 여부
3. 정렬 상태
4. 메모리 크기 (Hash Table을 올릴 수 있는가?)
5. 조인 결과 예상 건수
6. CPU vs I/O 비용
```

## 실무 가이드라인

| 상황 | 최적 조인 | 이유 |
|-----|---------|-----|
| 외부 < 1,000건, 인덱스 있음 | **NL** | M이 작아서 반복 비용 적음 |
| 양쪽 > 10,000건 | **Hash** | 선형 시간이 가장 효율적 |
| 이미 정렬됨 | **Sort Merge** | 정렬 비용 0 |
| 메모리 부족 | **Sort Merge** | Hash는 메모리 많이 필요 |
| 결과 많이 필요 | **Hash** | 병렬 처리 가능 |
| 결과 일부만 필요 | **NL** | 조기 종료 가능 |

결론: **O(M × log N)**에서 **log N**은 인덱스 덕분이고, M이 작을 때만 NL이 유리하다. M이 크면 Hash Join의 **O(M + N)**이 압도적으로 빠르다.
