## 실행 순서 설명

```
Rows     Row Source Operation
-------  --------------------------------
   100   NESTED LOOPS                        -- ③
   100     TABLE ACCESS FULL DEPT            -- ① (A)
  1000     TABLE ACCESS BY INDEX ROWID EMP   -- ② 반복 (B)
  1000       INDEX RANGE SCAN EMP_IDX        -- ② 반복 (C)
```

### 실제 실행 흐름:

**1단계: (A) DEPT 테이블 스캔**
```
DEPT 테이블에서 첫 번째 행 읽음 (예: 부서코드 'A01')
```

**2단계: (C) → (B) Inner 테이블 접근**
```
├─ (C) EMP_IDX 인덱스에서 'A01' 검색
└─ (B) 인덱스에서 찾은 ROWID로 EMP 테이블 접근
```

**3단계: DEPT의 다음 행으로 반복**
```
DEPT 테이블에서 두 번째 행 읽음 (예: 부서코드 'B02')
├─ (C) EMP_IDX 인덱스에서 'B02' 검색  
└─ (B) ROWID로 EMP 테이블 접근
...
(100번 반복)
```

## 올바른 순서 정리

**순서: (A) → [(C) → (B)] × 100번**

- **(A)**: 1번 실행 → 100건
- **(C)**: 100번 실행 → 1000건
- **(B)**: 100번 실행 → 1000건

## 왜 C가 B보다 먼저인가?

```
INDEX RANGE SCAN        (C) ← 먼저: 인덱스에서 ROWID 찾기
  ↓
TABLE ACCESS BY INDEX ROWID (B) ← 나중: ROWID로 테이블 접근
```

**인덱스 스캔이 선행되어야 ROWID를 얻을 수 있기 때문입니다!**

## 실행 계획 읽는 규칙

### 들여쓰기 규칙:
```
부모
  자식1        ← 자식들은 왼쪽에서 오른쪽, 위에서 아래
    손자1-1    ← 자식보다 먼저 실행
    손자1-2
  자식2
```

### 우리 예시 적용:
```
NESTED LOOPS              (마지막 실행)
  TABLE ACCESS FULL       (① 먼저 실행)
  TABLE ACCESS BY ROWID   (③ 나중 실행 - 반복)
    INDEX RANGE SCAN      (② 먼저 실행 - 반복)
```

## 상세 실행 타임라인

```
시간 →

① DEPT row 1 읽기
    ↓
  ② EMP_IDX에서 검색 (C)
    ↓  
  ③ EMP 테이블 접근 (B)
    ↓
④ DEPT row 2 읽기
    ↓
  ⑤ EMP_IDX에서 검색 (C)
    ↓
  ⑥ EMP 테이블 접근 (B)
    ↓
  ... 100번 반복
```


## 트레이스 결과 주요 항목들

### 1. **Rows (실제 처리된 행 수)**
```
Rows     Row Source Operation
-------  ---------------------
  100    TABLE ACCESS FULL EMPLOYEES
   50    INDEX RANGE SCAN EMP_IDX
```
- **의미**: 실제로 읽거나 반환된 행의 개수
- **중요**: 예상 Rows와 실제 Rows 차이가 크면 통계 정보 문제!

### 2. **Row Source Operation (실행 순서와 방법)**
```
Rows     Row Source Operation
-------  ---------------------
    1    SORT AGGREGATE                    -- ④ 최종 집계
  100      NESTED LOOPS                    -- ③ 조인
  100        TABLE ACCESS FULL DEPT        -- ① 먼저 실행
 1000        TABLE ACCESS BY INDEX ROWID EMP -- ② 반복 실행
 1000          INDEX RANGE SCAN EMP_IDX
```
- **들여쓰기**: 하위 작업 (자식 노드)
- **실행 순서**: 보통 **아래에서 위로**, **안쪽에서 바깥쪽**으로

### 3. **CR (Consistent Read - 논리적 읽기)**
```
call     count  cpu   elapsed  disk  query  current  rows
------- ------ ----- -------- ----- ------ -------- -----
Parse        1  0.00     0.00     0      0        0     0
Execute      1  0.00     0.00     0      0        0     0
Fetch      101  0.05     0.06    50   1500       10  1000
```
- **query 컬럼 = CR (Consistent Read)**
- **의미**: 버퍼 캐시에서 읽은 블록 수 (메모리 읽기 포함)
- **중요**: CR이 높으면 **비효율적인 SQL**

### 4. **PR (Physical Read - 물리적 읽기)**
```
disk = PR (Physical Read)
```
- **의미**: 디스크에서 실제로 읽은 블록 수
- **disk 50 = 50개 블록을 디스크에서 읽음**
- **중요**: PR이 높으면 **I/O 병목**

### 5. **PW (Physical Write)**
```
current = CU (Current Mode) + PW 관련
```
- **의미**: 디스크에 쓴 블록 수
- **언제?**: INSERT/UPDATE/DELETE, TEMP 작업 시
- **SORT, HASH JOIN 등에서 메모리 부족 시 증가**

### 6. **Time (소요 시간)**
```
cpu     elapsed
-----   --------
0.05    0.06      (초 단위)
```
- **cpu**: CPU 사용 시간 (실제 연산 시간)
- **elapsed**: 총 경과 시간 (I/O 대기 포함)
- **elapsed >> cpu**: I/O 대기가 많음 (디스크 느림)
- **cpu ≈ elapsed**: CPU 작업이 많음 (연산 집약적)

## 실전 예시 해석

```
Rows     Row Source Operation
-------  --------------------------------
   100   NESTED LOOPS
   100     TABLE ACCESS FULL DEPT              -- (A)
  1000     TABLE ACCESS BY INDEX ROWID EMP     -- (B)
  1000       INDEX RANGE SCAN EMP_IDX          -- (C)

call     count  cpu   elapsed  disk  query  current
------- ------ ----- -------- ----- ------ --------
Fetch      101  0.15     2.30   800   5000       50
```

### 해석:
1. **실행 순서**: (A) → (C) → (B)
   - DEPT 테이블 Full Scan (100건)
   - 각 DEPT 건마다 EMP 인덱스 스캔 (1000건)

2. **Rows 분석**:
   - DEPT: 100건 → 적절
   - EMP: 1000건 = 100 × 10건 → **NL 조인이 100번 반복**

3. **I/O 분석**:
   - **query(CR) = 5000**: 5000개 블록을 논리적으로 읽음
   - **disk(PR) = 800**: 그 중 800개는 디스크에서 읽음
   - **비율**: 800/5000 = 16% 물리적 I/O (나쁘지 않음)

4. **시간 분석**:
   - **cpu = 0.15초**: 실제 연산 시간
   - **elapsed = 2.30초**: 총 소요 시간
   - **차이 = 2.15초**: I/O 대기 시간이 대부분!
   - **결론**: 디스크 I/O가 병목

## 성능 문제 판단 기준

### 문제 신호들:

```
1. CR(query)이 지나치게 높음
   → 인덱스 비효율, 불필요한 테이블 스캔

2. PR(disk)이 높고 elapsed >> cpu
   → I/O 병목, 캐시 히트율 낮음

3. Rows가 예상과 다름
   → 통계 정보 오래됨, 옵티마이저 오판

4. NESTED LOOPS에서 Inner Rows가 과다
   → 조인 조건 잘못, 인덱스 없음
```

## 실무 팁

```sql
-- Oracle 10046 트레이스 활성화
ALTER SESSION SET EVENTS '10046 TRACE NAME CONTEXT FOREVER, LEVEL 12';

-- 실행할 SQL
SELECT /*+ 주석으로표시 */ * FROM ...;

-- 트레이스 비활성화
ALTER SESSION SET EVENTS '10046 TRACE NAME CONTEXT OFF';

-- 트레이스 파일 찾기
SELECT value FROM v$diag_info WHERE name = 'Default Trace File';
```
