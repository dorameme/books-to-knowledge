
# IN 리스트
IN 리스트 처리 방식은 크게 두 가지가 존재한다
1. “=`(= ANY)” 방식처럼 최적화되어 처리되는 경우(= IN list iterator)
2. 필터 방식(filtering, 즉 각각의 값을 조건으로 매번 체크하는 방식)



---

#  **필터 방식이 더 나은 경우**

## 1) **IN 리스트가 지나치게 크고, 카디널리티가 매우 높은 경우**

* IN 조건을 = 비교로 최적화하면 “값 하나당 빠른 탐색”을 기대하지만
* 값이 **수천~수만 개 이상**이면 오히려 optimizer가 각각의 값에 대해 탐색 계획을 세우느라 비용이 증가한다.
* 대량 IN 리스트는 **필터링 방식(하나씩 체크)**이 더 단순하고 실제 실행 시 효율적일 때가 있다.

**예시**

```sql
WHERE col IN (v1, v2, v3, ... v50000)
```

* 인덱스를 이용한 `= ANY` 방식: 5만 번 인덱스 탐색
* 필터 방식: 한 번 테이블 스캔 + 간단한 해시/비교
  → 테이블이 작거나 정렬되지 않은 경우 필터가 유리하다.

---

## 2) **IN 값들이 데이터에 매우 골고루 퍼져 있을 때**

= 방식(IN list iterator)은 각 값을 개별 인덱스 탐색한다.
하지만 데이터가 전체 테이블에 균등하게 뿌려져 있으면,
인덱스를 쓰더라도 **랜덤 I/O가 너무 많이 발생**한다.

이럴 때 필터 방식으로

* 테이블을 한 번만 스캔하면서
* IN 리스트를 메모리에서 해시 테이블로 체크
  하는 방식이 훨씬 빠르다.

---

## 3) **인덱스가 없거나 비효율적일 때**

컬럼에 인덱스가 없으면 = 방식은 전혀 이득이 없다.
오히려 쓸데없이 최적화 비용만 든다.

이때는 어차피 풀스캔하므로
필터 방식이 더 단순하고 빠르다.

---

## 4) **IN 리스트가 매우 동적이라 bind 변수로 들어올 때**

IN 리스트 최적화는 정적 SQL에서 효과적인데,
다음과 같이 바인딩될 경우

```sql
WHERE col IN (:v1, :v2, ..., :vN)
```

Oracle / MySQL 모두

* cardinality 예측 실패
* plan 캐싱 실패
* iterator 방식 적용 어려움
  이 발생하여, 필터 방식이 오히려 안정적이다.

---

## 5) **IN 리스트가 소수일 때보다 중간 크기(수십~수백)일 때**

* IN 개수가 10~20개면 = 방식(iterator)이 유리
* IN 개수가 100~1000개면 필터 방식이 유리해지는 구간이 존재한다

왜?

= 방식(IN list iterator)
→ 값 하나씩 인덱스 lookup → 랜덤 액세스 증가

필터 방식
→ 1번의 스캔으로 모두 체크 → I/O 패턴이 안정적

---

# 🔍 **정리**

| 케이스    | IN list iterator(= 방식) 유리 | 필터 방식 유리          |
| ------ | ------------------------- | ----------------- |
| IN 개수  | 작음(10~20)                 | 큼(수백~수천 이상)       |
| 인덱스    | 존재, 매우 selective          | 없음, low selective |
| 데이터 분포 | 특정 값에 편향                  | 전체에 퍼짐            |
| I/O 패턴 | 랜덤 I/O OK                 | 랜덤 I/O 비효율        |

---

#  결론

**인덱스를 통한 IN list iterator(= 방식)가 항상 빠른 것이 아니다.**
다음 상황에서는 오히려 필터 방식이 더 좋다.

* IN 리스트가 매우 클 때
* 데이터가 골고루 퍼져 있을 때
* 인덱스가 없거나 선택도가 낮을 때
* 랜덤 인덱스 lookup보다 테이블 스캔 + 필터가 더 저렴할 때

즉, **“선택도가 낮은 IN 조건”은 필터 방식이 더 낫다**는 것이 핵심이다.
