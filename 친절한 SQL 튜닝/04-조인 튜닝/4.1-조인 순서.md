
# **조인 순서 + 조건절 순서 + 인덱스 조건 적용 순서**


# 1. 먼저 SQL 원문 구조를 보자

조건절에 번호가 붙어 있다:

```
where ① c.회원구분 = '홍길동'
and   ② e.입사일자 > '19960101'
and   ③ c.전화번호 = '7123'
and   ④ e.최종주문금액 > 20000
```

그리고 힌트가 이렇게 들어간 상태:

```
ordered use_nl(c) index(e) index(c)
```

즉:

1. **FROM 순서대로** 조인이 실행된다
   → `from 사원 e, 고객 c` → e 먼저, c 다음
2. 조인 방식: **NL Join**
3. e와 c 둘 다 인덱스를 사용

---

# 2. 실행 순서(조건절 처리 순서) = 2 → 3 → 1 → 4

이 이유는 **NL Join + 인덱스 구조** 때문이다.

---

# 3. 핵심 원리 3가지

## 원리 1. Outer 테이블(e)에 대한 조건은 먼저 적용됨

FROM 절 순서가 `e → c` 이므로:

1. e 테이블을 먼저 ACCESS
2. 그 다음 e의 결과값을 기반으로 c에 접근

그래서 e 조건이 먼저 실행됨 → ②, ④

---

## 원리 2. 인덱스 선두 컬럼 조건이 먼저 적용됨

e 테이블의 인덱스 X1은 이렇게 구성됨:

```
X1: 최종주문금액 + 입사일자
```

인덱스를 Range Scan 하려면 **선두 컬럼**을 먼저 조건으로 사용한다.

따라서 e 테이블 조건 처리 우선순위는:

1. **② 입사일자 > …** (여기가 Range 시작 조건)
2. **④ 최종주문금액 > …** (Range 좁히는 추가 조건)

책에서는 표기된 순서가 ② → ④이지만
실제 내부적으로는 인덱스 구조가 좌→우로 가서
`입사일자`가 먼저 사용됨.

이로 인해 최종적으로 실행 계획에서 보이는 조건 적용 순서가 ② → ③ → ① → ④처럼 나타남.

---

## 원리 3. NL Join에서는 조인 대상(c 테이블) 조건은 나중에 적용됨

NL Join의 구조는 이거다:

```
for each row in e {
    find matching rows in c using index on c
}
```

즉:

1. e 조건 먼저 → ②와 ④
2. e 결과 한 건씩 가져와서
   c 인덱스에서 검색할 때 → ③과 ① 순서 적용

그래서 c 조건이 나중에 등장한다.

---

# 4. 이제 실제 순서를 보자

### ① e 테이블 먼저 접근

→ e의 인덱스 X1 조건이 먼저 적용됨
→ 그중 선두 열인 “입사일자 조건(②)”이 실제 범위를 결정함

### ② e의 한 row마다 NL로 c 접근

→ c 인덱스 X1을 사용

c 인덱스 구성:

```
c 인덱스 X1: 회원구분 + 전화번호
```

**인덱스 선두 컬럼(회원구분 ①)이 먼저 적용되고
뒤에 이어 전화번호(③)가 적용된다.**

하지만 옵티마이저가 통계 기반으로 필터링 효과가 더 큰 조건(전화번호)을 먼저 전체 계획에서 최적화 순으로 보여줄 수 있기 때문에 실행 순서에서 ③이 먼저 등장하고 ①이 뒤에 등장하는 것처럼 보인다.

---

# 5. 실제 실행 순서 = ② → ③ → ① → ④ 의 의미

정확히 말하면:

* **②와 ④는 e 테이블 필터 조건**
* **③과 ①은 c 테이블 필터 조건**

하지만 실행계획 출력에서는 “필터 적용 순서” 기준으로 표시되기 때문에
선택도 높은 순서(더 잘 걸러지는 조건)를 앞쪽에 표시한다.

전화번호(③)는 선택도가 높음
회원구분(①)은 선택도가 낮음
그래서 ③이 ①보다 먼저 표시됨.

---

# 6. 결론

실행 순서가 ② → ③ → ① → ④인 이유는:

1. FROM 순서 때문에 e 테이블 조건이 먼저 실행됨
2. 인덱스 선두 컬럼 기반으로 필터링
3. NL Join 구조상 c 조건은 e 다음에 실행
4. 선택도가 높은 조건(전화번호 ③)을 먼저 적용하기 때문
