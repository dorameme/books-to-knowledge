# 조인 방식
## 1. 개요

NL Join, Hash Join, Sort-Merge Join은 데이터베이스에서 많이 사용되는 대표적인 조인 방식이다.

---

## 2. NL Join (Nested Loop Join)

NL Join은 한 테이블의 각 행에 대해 다른 테이블에서 매칭되는 행을 반복적으로 찾는 방식이다.

### 동작 예시

```
customer 테이블: 10건
orders 테이블: 100만 건
```

쿼리:

```
SELECT *
FROM customer c
JOIN orders o ON c.id = o.customer_id
WHERE c.id = 5;
```

### 동작 과정

1. 고객 테이블에서 id=5 한 건을 읽는다.
2. orders 테이블에서 customer_id=5를 인덱스로 검색한다.
3. 매칭되는 주문만 가져온다.

### 특징

* Outer 테이블(고객) 건수가 적을수록 빠르다.
* Inner 테이블에 인덱스가 있을 때 최고의 성능을 낸다.
* 랜덤 액세스가 폭발하면 느려진다.

### 언제 느려지는가?

```
WHERE c.grade IN ('A','B','C')   -- 고객 30만 명 조회
```

→ 고객 30만 건 × 주문 인덱스 검색 30만 번 → 랜덤 IO 과다 → 느림

### 정리

소량 데이터 조인, 인덱스 기반 조인에 강하다.

---

## 3. Hash Join

Hash Join은 한 테이블을 해시 테이블로 만들고, 다른 테이블의 행을 순차적으로 비교하여 매칭하는 방식이다.

### 동작 예시

```
orders 테이블: 100만 건
product 테이블: 50만 건
```

쿼리:

```
SELECT *
FROM orders o
JOIN product p ON o.product_id = p.id;
```

### 동작 과정

1. product 테이블을 메모리에 해시 테이블로 생성한다.
2. orders 테이블을 스캔하며 해시 테이블을 이용해 매칭한다.

### 특징

* 인덱스 없이도 대량 데이터 조인에 강하다.
* 메모리에 해시 자료구조를 만들기 때문에 속도가 빠르다.

### 단점

* 메모리 사용량이 많다.
* 메모리 부족 시 디스크를 사용하며 성능이 크게 떨어진다.

### 정리

대량 데이터 조인, 인덱스 없는 조인에 적합하다.

---

## 4. Sort-Merge Join

Sort-Merge Join은 두 테이블을 조인 키로 정렬한 후, 정렬된 두 결과를 병합하여 조인한다.

### 동작 예시

```
logs 테이블: 시간 기준 정렬되지 않음
errors 테이블: 시간 기준 정렬되지 않음
```

쿼리:

```
SELECT *
FROM logs l
JOIN errors e ON l.event_time = e.event_time;
```

### 동작 과정

1. logs 테이블을 event_time 기준으로 정렬한다.
2. errors 테이블도 event_time 기준으로 정렬한다.
3. 두 정렬된 데이터를 한 번씩 읽으며 병합한다.

### 특징

* 정렬된 데이터를 병합하기 때문에 대량 범위 조인에 매우 효율적이다.
* 인덱스가 없으면 초기 정렬 비용이 크다.

### 정리

대용량 범위 조인, 정렬 기반 조인에서 강력하다.

---

## 5. 조인 방식 비교 표

| 조인 방식           | 동작 방식                   | 장점                | 단점           | 적합한 상황       | 예시               |
| --------------- | ----------------------- | ----------------- | ------------ | ------------ | ---------------- |
| NL Join         | Outer 루프 + Inner 인덱스 검색 | 소량 조인 빠름, 인덱스 기반  | 랜덤 IO 많으면 느림 | OLTP, 인덱스 있음 | 고객 1명 + 주문 조회    |
| Hash Join       | 한 테이블 해시 후 비교           | 대량 조인 강함, 인덱스 불필요 | 메모리 크게 필요    | OLAP, 대량 조인  | 주문 100만 + 상품 50만 |
| Sort-Merge Join | 정렬 후 병합                 | 범위 조인 강력, 대용량에 효율 | 정렬 비용 큼      | 날짜·범위 중심 조인  | 로그 시각 조인         |

---

* **NL Join**: 인덱스가 있고 소량 조인일 때 가장 적합하다.
* **Hash Join**: 인덱스가 없고 대량 조인일 때 성능이 좋다.
* **Sort-Merge Join**: 정렬된 상태이거나 범위 조인일 때 유리하다.

상황에 따라 최적의 조인 방식을 선택해야 쿼리 성능을 극대화할 수 있다.


맞다. 일반적으로 데이터베이스에서 **조인 알고리즘 선택은 옵티마이저가 결정**한다. 사용자가 직접 NL Join인지 Hash Join인지 명시하는 경우는 드물다.

하지만 **어떤 조인 방식이 쓰였는지 확인하는 방법**과 **사용자가 유추할 수 있는 기준**은 있다.

---

# 1. 옵티마이저가 조인 방식을 결정하는 기준

1. **테이블 크기**

   * 작은 테이블과 큰 테이블 → NL Join
   * 두 테이블 모두 크고 인덱스 없음 → Hash Join

2. **인덱스 존재 여부**

   * Inner 테이블에 인덱스가 있으면 NL Join 선호
   * 인덱스가 없으면 Hash Join이나 Sort-Merge Join

3. **통계 정보**

   * 테이블 통계, 컬럼 선택도, 필터링 비율 등을 보고 최적 계획 선택

4. **메모리/IO 고려**

   * Hash Join은 메모리 기반이므로 메모리 부족 시 다른 방식 선택 가능

---

# 2. 사용자가 조인 방식을 확인하는 방법

## 2.1 실행 계획(EXPLAIN)

대부분 DBMS에서 `EXPLAIN` 명령어로 확인 가능.

예, MySQL:

```sql
EXPLAIN SELECT * 
FROM orders o 
JOIN products p ON o.product_id = p.id;
```

* `type` 또는 `Extra` 컬럼에서 NL Join, Hash Join, Merge Join 등 표시

예, Oracle:

```sql
EXPLAIN PLAN FOR
SELECT * FROM orders o JOIN products p ON o.product_id = p.id;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

* `Nested Loops`, `Hash Join`, `Sort Merge Join` 형태로 나옴

---

## 2.2 유추하는 방법

| 조건                             | 유추 방식                  |
| ------------------------------ | ---------------------- |
| Outer 테이블 적고 Inner 테이블에 인덱스 있음 | NL Join 가능성이 높음        |
| 양쪽 테이블 모두 크고 인덱스 없음            | Hash Join 가능성 높음       |
| 양쪽 테이블 정렬되었거나 정렬 필요            | Sort-Merge Join 가능성 높음 |

즉, **사용자는 통계와 인덱스, 테이블 크기를 보고 추정**하고, **정확한 정보는 실행 계획(EXPLAIN)으로 확인**한다.

---

# 3. 결론

* **사용자가 직접 NL/Hash/Sort-Merge Join을 선택하는 경우는 거의 없음**
* 대부분 DB 옵티마이저가 알아서 최적의 조인 방식을 선택
* 조인 방식 확인과 성능 분석은 **EXPLAIN 실행 계획**을 통해 가능
* 테이블 크기, 인덱스, 필터 조건을 보고 유추 가능


