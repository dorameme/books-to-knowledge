# 소켓과 포트의 차이, 그리고 UDP vs TCP

<img width="709" height="642" alt="image" src="https://github.com/user-attachments/assets/c5838da9-5171-4d6e-92c3-7dc874a52d42" />

## 소켓과 포트는 다르다

### 포트(Port)란?

포트는 논리적인 번호다. 0번부터 65535번까지 있다.

- 건물의 문 번호와 같다
- 어떤 애플리케이션으로 데이터를 보낼지 결정하는 주소 역할
- 16비트 숫자일 뿐이다

예시:
- 80번: 웹 서버
- 443번: HTTPS
- 53번: DNS
- 3306번: MySQL

### 소켓(Socket)이란?

소켓은 실제 통신 창구다. 프로그램이 네트워크 통신을 하기 위해 운영체제가 만들어주는 객체다.

- 건물 안의 실제 사무실과 같다
- 데이터를 주고받는 실제 통로
- 파일 디스크립터처럼 운영체제가 관리하는 자원이다

소켓에 저장되는 정보:
- 프로토콜 종류 (TCP/UDP)
- 로컬 IP와 포트
- 원격 IP와 포트
- 연결 상태
- 송수신 버퍼

### 관계 비유

```
건물(IP 주소)
└─ 문 번호(포트): 80번
   └─ 실제 사무실(소켓)
      - UDP: 사무실 1개로 모든 방문자 처리
      - TCP: 방문자마다 전용 사무실 배정
```

## UDP의 동작 방식

### 소켓과 포트: 1:1 관계

```
프로그램이 UDP 소켓을 생성하고 53번 포트에 바인딩

포트 53번
└─ 소켓 1개 (끝)

클라이언트 A (1.1.1.1:5000) → 소켓
클라이언트 B (2.2.2.2:6000) → 같은 소켓
클라이언트 C (3.3.3.3:7000) → 같은 소켓
```

### 처리 방식: 1:N (하나의 소켓으로 여러 클라이언트)

서버는 데이터를 받을 때마다 "누가 보냈는가"를 확인한다.

```python
sock = socket.socket(SOCK_DGRAM)
sock.bind(('0.0.0.0', 53))

while True:
    data, (client_ip, client_port) = sock.recvfrom(1024)
    # 매번 주소를 받아서 누군지 확인
    response = process(data)
    sock.sendto(response, (client_ip, client_port))
    # 받은 주소로 다시 보냄
```

### 특징

- 소켓 생성 비용이 적다 (1개만 필요)
- 메모리 효율적이다
- 빠르다
- 연결 개념이 없다
- 신뢰성이 없다 (패킷 손실 가능)
- 순서 보장 안 된다

## TCP의 동작 방식

### 소켓과 포트: N:1 관계

```
프로그램이 TCP 소켓을 생성하고 80번 포트에 바인딩

포트 80번
├─ 리스닝 소켓 (연결 대기용)
├─ 연결 소켓 A (클라이언트 A 전용)
├─ 연결 소켓 B (클라이언트 B 전용)
└─ 연결 소켓 C (클라이언트 C 전용)

같은 포트에 소켓이 여러 개 존재한다
```

### 처리 방식: 1:1 (각 클라이언트마다 전용 소켓)

```python
listen_sock = socket.socket(SOCK_STREAM)
listen_sock.bind(('0.0.0.0', 80))
listen_sock.listen()

while True:
    # 클라이언트 접속마다 새 소켓 생성
    client_sock, addr = listen_sock.accept()
    
    # 이 소켓은 이 클라이언트 전용
    data = client_sock.recv(1024)
    client_sock.send(response)
    # 주소를 명시하지 않아도 됨 (이미 연결됨)
```

### 특징

- 소켓이 많이 필요하다 (클라이언트 수만큼)
- 메모리를 더 쓴다
- 연결 설정에 시간이 걸린다 (3-way handshake)
- 신뢰성이 있다 (패킷 손실 시 재전송)
- 순서가 보장된다
- 연결 상태를 유지한다

## 운영체제가 보는 소켓 테이블

### UDP 서버 (포트 53)

```
프로토콜  로컬주소        원격주소         소켓ID
UDP      0.0.0.0:53      :             sock1

총 1개의 소켓
```

### TCP 서버 (포트 80, 클라이언트 3명)

```
프로토콜  로컬주소          원격주소              소켓ID   상태
TCP      0.0.0.0:80        0.0.0.0:0            sock1    LISTEN
TCP      192.168.1.5:80    10.0.0.1:5000        sock2    ESTABLISHED
TCP      192.168.1.5:80    10.0.0.2:6000        sock3    ESTABLISHED
TCP      192.168.1.5:80    10.0.0.3:7000        sock4    ESTABLISHED

총 4개의 소켓
```

운영체제는 4가지 정보로 TCP 소켓을 구분한다:
- 출발지 IP
- 출발지 포트
- 목적지 IP
- 목적지 포트

이 4가지가 다르면 다른 소켓이다.

## 왜 TCP는 이렇게 복잡하게 만들었나?

TCP는 각 연결마다 다음을 별도로 관리해야 한다:

1. 순서번호: 패킷이 순서대로 도착했는지 확인
2. 확인응답번호: 어디까지 받았는지 추적
3. 윈도우 크기: 얼마나 빠르게 보낼지 조절
4. 재전송 타이머: 패킷 손실 시 재전송
5. 연결 상태: ESTABLISHED, CLOSE_WAIT 등

이 모든 정보를 클라이언트마다 따로 저장하려면 소켓이 분리되어야 한다.

UDP는 이런 것들이 필요 없으니 소켓 1개면 충분하다.

## 실제 사용 예시

### UDP 사용 사례

DNS 조회:
- 질문 하나, 답변 하나면 끝
- 빠른 응답이 중요
- 실패하면 다시 물어보면 됨

실시간 게임:
- 플레이어 위치를 계속 전송
- 하나 손실돼도 다음 위치가 금방 옴
- 빠른 업데이트가 중요

음성/영상 통화:
- 약간의 노이즈는 괜찮음
- 끊김 없는 재생이 중요
- 지연시간이 치명적

### TCP 사용 사례

웹 페이지 로딩:
- HTML 파일이 정확해야 함
- 이미지가 깨지면 안 됨
- 순서대로 받아야 함

파일 다운로드:
- 바이트 하나도 손실되면 안 됨
- 순서가 중요함
- 느려도 정확해야 함

이메일 전송:
- 내용이 바뀌면 안 됨
- 전송 실패 시 재시도 필요

## 최종 비교 정리

```
구분              UDP                    TCP
─────────────────────────────────────────────────────
포트와 소켓       1:1                    N:1
소켓과 클라이언트  1:N                    1:1
연결 개념         없음                    있음
신뢰성           없음                    있음
순서 보장         없음                    있음
속도             빠름                    느림
오버헤드          적음                    많음
소켓 개수         1개                    클라이언트 수 + 1
사용 예시         DNS, 게임, 스트리밍      웹, 파일전송, 이메일
```

핵심은 이것이다:

UDP는 소켓 1개로 여러 클라이언트를 처리한다.
TCP는 클라이언트마다 전용 소켓을 만든다.

포트는 그냥 번호다. 소켓은 실제 통신 창구다.

# 하나의 연결에 소켓이 여러개인 이유?

병렬성 문제가 아니라 상태 관리의 기술적 한계 때문.

TCP는 하나의 소켓에서 여러 연결을 처리할 수 없다. 그 이유는:

---

## 핵심 이유: 각 연결의 상태 정보가 독립적이어야 함

TCP는 연결마다 다음과 같은 고유 상태 정보를 유지해야 함:

1. 시퀀스 번호 (Sequence Number)
   - 데이터의 순서를 관리
   - 각 연결마다 시작 번호가 다름

2. 확인 응답 번호 (ACK Number)
   - 상대방이 받은 데이터 위치 추적
   - 연결별로 완전히 독립적

3. 흐름 제어 정보 (Flow Control)
   - 윈도우 크기(Window Size)
   - 각 클라이언트의 처리 속도가 다름

4. 재전송 타이머 및 데이터
   - 손실된 데이터 복구
   - 각 연결별로 별도 관리 필요

---

## 기술적 한계: 데이터가 섞이면 구분 불가능

### 가정: 하나의 소켓에 두 연결(A,B)의 데이터가 섞여 들어온다면

```
소켓으로 들어오는 데이터:
[연결A 데이터 chunk1] [연결B 데이터 chunk1] [연결A 데이터 chunk2]
```

문제:
- 어떤 데이터가 어떤 연결의 것인지 구분할 방법이 없음
- 시퀀스 번호 관리 불가능 (A와 B의 번호 체계가 다름)
- 재전송 시 어떤 데이터를 재전송해야 할지 알 수 없음
- 연결 종료 시 특정 연결만 종료 불가능

---

## TCP 헤더 설계의 근본적 제약

TCP 세그먼트 헤더에는 연결을 식별할 수 있는 필드가 없다:
- 출발지 포트, 목적지 포트만 존재
- 어떤 "연결 ID" 필드가 없음
- 따라서 운영체제는 4가지 정보(로컬IP:포트 + 원격IP:포트)로 연결을 구분해야 함

이것이 각 연결마다 별도 소켓이 필요한 근본 이유.

---

## 결론

TCP가 하나의 소켓에서 여러 연결을 처리할 수 없는 이유는 병렬성 문제가 아니라, TCP 프로토콜 자체의 설계적 한계 때문.       
연결별 상태 정보를 분리하여 관리할 방법이 없기 때문에,      
소켓이라는 추상화를 통해 각 연결을 완전히 격리시켜야 함.     




## TCP 연결이 1:1이 맞지만, "서비스 제공"은 1:N이어야 함.

### 핵심: 서버의 관점 vs 클라이언트의 관점

#### 1. 클라이언트 관점:
```
클라이언트: "나는 서버의 포트 80에 연결하고 싶다"
클라이언트 소켓 생성 → 서버IP:80에 연결
결과: [내IP:임시포트] ↔ [서버IP:80] (1:1 연결)
```
- 클라이언트에게는 정말 1:1 연결입니다.

#### 2. 서버 관점:
```
서버: "나는 포트 80으로 들어오는 모든 연결을 처리해야 한다"
포트 80 리스닝 → 
    - 클라이언트A 연결 요청 → 연결 소켓A 생성
    - 클라이언트B 연결 요청 → 연결 소켓B 생성
    - 클라이언트C 연결 요청 → 연결 소켓C 생성
결과: 서버IP:80에 연결된 클라이언트 A, B, C (1:N 서비스)
```

---

## 왜 포트 1:소켓 N이 필요한가?

### 단순 비교: 포트 1:소켓 1이라면?

```
가정: 서버 포트 80에 소켓이 딱 1개만 있을 수 있다면

현재 상황: 
클라이언트A가 포트 80에 연결 중
클라이언트B가 연결 요청 → "포트 80 사용 중" → 연결 거부
클라이언트C가 연결 요청 → "포트 80 사용 중" → 연결 거부

결과: 서버는 한 번에 1명의 클라이언트만 처리 가능
```

이것이 문제!

---

## 실제 필요성: 웹 서버 예시

### 네이버 메인 페이지 접속 시:
```
사용자 10만 명이 동시에 https://naver.com 접속
naver.com 서버 IP: 223.130.200.107
HTTPS 포트: 443

현실 구현:
- 서버IP:443에 리스닝 소켓 1개
- 사용자A 연결 → 연결 소켓 1 생성
- 사용자B 연결 → 연결 소켓 2 생성
- ...
- 사용자100,000 연결 → 연결 소켓 100,000 생성

이론적 구현 (포트 1:소켓 1이라면):
- 서버IP:443에 소켓 1개
- 사용자A 연결 → 연결 성공
- 사용자B 연결 → "포트 443 사용 중" → 실패
- 사용자C 연결 → "포트 443 사용 중" → 실패
```

---

## 기술적 메커니즘

### 리스닝 소켓 vs 연결 소켓

```
서버 시작:
1. 리스닝 소켓 생성 (포트 80 바인딩)
   - 이것이 "서비스 포트"를 여는 것
   - 클라이언트의 연결 요청을 받음

2. 클라이언트 연결 시:
   accept() 함수 호출
   → 새로운 연결 소켓 생성
   → 이 연결 소켓도 포트 80 사용
   → 리스닝 소켓은 계속 새로운 연결 대기

결과 구조:
리스닝 소켓: 서버IP:80 (새 연결 수락)
연결 소켓 A: 서버IP:80 ↔ 클라이언트A_IP:55000
연결 소켓 B: 서버IP:80 ↔ 클라이언트B_IP:55001
연결 소켓 C: 서버IP:80 ↔ 클라이언트C_IP:55002
```

---

### "포트 1:소켓 N"이 의미하는 것

이 말은 "하나의 서비스 포트가 여러 연결을 수용한다" 는 의미.

포트 80 = 웹 서비스
- 포트 80 하나로 수만 개의 HTTP 연결 처리
- 각 연결은 자신의 소켓을 가짐
- 모든 소켓이 포트 80을 통해 통신

### 비유로 이해하기

| 개념 | 비유 | 설명 |
|------|------|------|
| 포트 80 | 회사 대표 전화번호 (02-1234-5678) | |
| 리스닝 소켓 | 전화교환원 | 새 전화 연결 수락 |
| 연결 소켓 A | 사원 김대리와 고객A의 전화통화 | |
| 연결 소켓 B | 사원 이과장과 고객B의 전화통화 | |
| 연결 소켓 C | 사원 박사장과 고객C의 전화통화 | |

핵심: 
- 대표번호(포트 80) 하나로 여러 통화(연결) 동시 진행
- 각 통화는 별도의 회선(소켓)
- 교환원(리스닝 소켓)은 새 전화만 받음

---
<img width="863" height="219" alt="image" src="https://github.com/user-attachments/assets/f5a60e70-63d4-4351-b4f7-fa326d85138d" />

## 정리: 왜 포트 1:소켓 N이 필요한가?

1. 서비스 식별성: 클라이언트가 서버의 특정 서비스(웹, FTP, 메일 등)를 찾으려면 고정된 포트 번호가 필요

2. 동시성: 하나의 서비스가 여러 클라이언트를 동시에 처리해야 함

3. 연결 격리: 각 클라이언트의 통신 상태(시퀀스 번호, 버퍼 등)를 별도로 관리해야 함

4. 자원 관리: 각 연결마다 독립적인 메모리 버퍼, 타이머, 상태 정보 필요

따라서:
- 포트는 "무엇을" (웹서비스인지, FTP인지)
- 소켓은 "누구와" (어떤 클라이언트와의 연결인지)

를 나타내며, 하나의 서비스(포트)가 여러 클라이언트(소켓)를 처리하기 위해 포트 1:소켓 N 구조가 필수적.

최종 결론: TCP 연결 자체는 1:1이 맞지만, 하나의 서비스 포트가 여러 1:1 연결을 동시에 제공해야 하므로 포트 1:소켓 N 구조가 필요.
