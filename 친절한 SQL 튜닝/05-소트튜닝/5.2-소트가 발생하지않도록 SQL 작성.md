<img width="471" height="575" alt="Image" src="https://github.com/user-attachments/assets/358f4a3f-d658-4220-85c0-be545d15568a" />


## 핵심 개념

이 페이지는 **조인 조건을 먼저 처리하여 성능을 개선하는 방법**을 설명하고 있다.

## 첫 번째 예시 분석

### 원본 쿼리
```sql
select c.계약번호, c.상품코드, p.상품명, p.상품구분코드, c.계약일시, c.계약금액
from 계약 c, 상품 p
where c.지점ID = :brch_id
and p.상품코드 = c.상품코드
order by c.계약일시 desc
```

### 실행 계획 해석
```
0  SELECT STATEMENT
1    0  SORT (ORDER BY)
2      1  HASH JOIN
3        2  TABLE ACCESS (FULL) OF '상품' (TABLE)
4        2  TABLE ACCESS (BY INDEX ROWID) OF '계약' (TABLE)
5          4  INDEX (RANGE SCAN) OF '계약_X01' (INDEX)
```

**문제점:**
- 상품 테이블을 FULL SCAN한다 (3번 라인)
- 그 다음에 계약 테이블과 조인한다
- 조인 후에 정렬한다

즉, **불필요하게 많은 상품 데이터를 읽어온 후 조인**하게 된다.

## 두 번째 예시 (개선된 쿼리)

### 힌트 적용 쿼리
```sql
select /*+ leading(c) use_nl(p) */
  c.계약번호, c.상품코드, p.상품명, p.상품구분코드, c.계약일시, c.계약금액
from 계약 c, 상품 p
where c.지점ID = :brch_id
and p.상품코드 = c.상품코드
order by c.계약일시 desc
```

### 개선된 실행 계획
```
0  SELECT STATEMENT
1    0  NESTED LOOPS
2      1  NESTED LOOPS
3        2  TABLE ACCESS (BY INDEX ROWID) OF '계약' (TABLE)
4          3  INDEX (RANGE SCAN DESCENDING) OF '계약_X01' (INDEX)
5        2  INDEX (UNIQUE SCAN) OF '상품_PK' (INDEX (UNIQUE))
6      1  TABLE ACCESS (BY INDEX ROWID) OF '상품' (TABLE)
```

**개선 효과:**
1. **계약 테이블을 먼저 조회**한다 (3-4번 라인)
   - `where c.지점ID = :brch_id` 조건으로 필터링
   - 인덱스로 정렬된 순서대로 읽어옴 (DESCENDING)

2. **계약별로 상품을 하나씩 조인**한다 (5-6번 라인)
   - 필요한 상품만 인덱스로 직접 접근
   - FULL SCAN 불필요

3. **정렬이 생략**된다
   - 이미 인덱스 순서대로 읽어왔기 때문

## 핵심 차이점 비교표

| 구분 | 첫 번째 쿼리 | 두 번째 쿼리 (개선) |
|------|------------|------------------|
| 조인 순서 | 상품 → 계약 | 계약 → 상품 |
| 상품 테이블 접근 | FULL SCAN | INDEX 직접 접근 |
| 조인 방식 | HASH JOIN | NESTED LOOPS |
| 정렬 | 필요 (SORT) | 불필요 (이미 정렬됨) |
| 읽는 데이터량 | 전체 상품 | 필요한 상품만 |

## 왜 이렇게 동작하는가?

### 첫 번째 쿼리의 문제
- 옵티마이저가 상품 테이블을 먼저 읽기로 결정
- 전체 상품 데이터를 메모리에 올림
- 그 다음 계약 테이블과 조인
- 비효율적

### 두 번째 쿼리의 장점
- `leading(c)`: 계약 테이블을 먼저 읽으라는 힌트
- `use_nl(p)`: Nested Loop 조인을 사용하라는 힌트
- 특정 지점의 계약만 먼저 찾음 (데이터가 적음)
- 해당 계약의 상품만 인덱스로 찾음 (효율적)

## 실무 적용 팁

이런 최적화가 필요한 경우:
1. 한쪽 테이블의 데이터가 훨씬 적을 때
2. WHERE 조건으로 한쪽을 크게 줄일 수 있을 때
3. 정렬 순서가 인덱스 순서와 일치할 때

마지막 문장의 의미:
> "겸험 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있다."

즉, **조인 키로 이미 정렬되어 있다면 추가 정렬이 필요 없다**는 뜻이다.




# 옵티마이저가 해시 조인을 선택한 이유?

## 옵티마이저의 판단 근거

### 1. 통계 정보 기반 판단

옵티마이저는 **테이블 통계 정보**를 보고 판단한다:

```
옵티마이저가 본 것:
- 상품 테이블: 1,000건 (적음)
- 계약 테이블: 100,000건 (많음)
- :brch_id로 필터링되는 계약: 예상 50,000건 (여전히 많음)
```

이 경우 옵티마이저 입장에서:
- "상품은 작으니까 전체를 메모리에 올려도 괜찮겠다"
- "계약은 많으니까 Hash Join이 빠르겠다"

### 2. 조인 방식별 특징

| 조인 방식 | 언제 유리한가 | 비용 계산 |
|---------|------------|---------|
| **Hash Join** | 양쪽 테이블이 모두 클 때 | O(M + N) |
| **Nested Loop** | 한쪽이 매우 작고, 인덱스가 있을 때 | O(M × log N) |
| **Sort Merge** | 이미 정렬되어 있을 때 | O(M log M + N log N) |

### 3. 첫 번째 쿼리에서 Hash Join을 선택한 이유

```sql
where c.지점ID = :brch_id  -- 이 조건이 얼마나 걸러줄지 모름
and p.상품코드 = c.상품코드
```

**옵티마이저의 잘못된 예측:**
- 지점ID 조건이 데이터를 충분히 안 걸러줄 것으로 예상
- 계약 건수가 여전히 많을 것으로 추정
- → "Hash Join이 안전하겠다"

**실제 상황 (사람이 아는 것):**
- 특정 지점의 계약은 100건 정도로 적음
- → "Nested Loop가 훨씬 빠르다"

## 왜 처음부터 NL을 안 쓰나?

### 문제 1: 부정확한 통계

```sql
-- 옵티마이저 예상
WHERE c.지점ID = :brch_id  
→ 예상: 50,000건 조회 (전체의 50%)

-- 실제
→ 실제: 100건만 조회 (전체의 0.1%)
```

통계가 오래되었거나 데이터 분포가 불균등하면 잘못 판단한다.

### 문제 2: 바인드 변수의 한계

```sql
where c.지점ID = :brch_id  -- 바인드 변수
```

옵티마이저는 **:brch_id의 실제 값**을 모른다:
- 어떤 지점인지 모름
- 해당 지점의 계약이 몇 건인지 모름
- → 평균값으로 예측할 수밖에 없음

### 문제 3: 최악의 경우 대비

옵티마이저는 **안전한 선택**을 선호한다:

| 시나리오 | Hash Join | Nested Loop |
|---------|----------|-------------|
| 계약 100건 (실제) | 약간 느림 | 매우 빠름 ✓ |
| 계약 50,000건 | 빠름 ✓ | **치명적으로 느림** |

- Hash Join: 최악의 경우에도 나쁘지 않음
- Nested Loop: 최악의 경우 재앙적
- → 옵티마이저는 Hash Join 선택

## 실제 성능 비교

### 시나리오: 특정 지점의 계약 100건

```
Hash Join 방식:
1. 상품 전체 읽기: 1,000건
2. 계약 필터링: 100건
3. Hash Join 수행
→ 총 I/O: 약 1,100회

Nested Loop 방식:
1. 계약 필터링: 100건
2. 각 계약마다 상품 찾기: 100번 × 1회 I/O
→ 총 I/O: 약 200회 (5배 빠름!)
```

## 힌트가 필요한 이유

개발자가 **업무를 더 잘 안다**:
- "이 지점은 항상 계약이 적어"
- "상품은 계약보다 훨씬 많아"
- "인덱스가 잘 되어 있어"

그래서 힌트로 강제한다:
```sql
/*+ leading(c) use_nl(p) */
-- "계약을 먼저 읽고, Nested Loop 써!"
```

## 정리표

| 구분 | 옵티마이저의 판단 | 실제 상황 | 해결책 |
|------|----------------|---------|-------|
| 계약 건수 예측 | 많음 (50,000건) | 적음 (100건) | 힌트 사용 |
| 최적 조인 방식 | Hash Join | Nested Loop | `use_nl()` |
| 조인 순서 | 상품 → 계약 | 계약 → 상품 | `leading(c)` |
| 정렬 | 별도 수행 | 인덱스 활용 | 생략 가능 |

결론: 옵티마이저는 **통계와 안전성**을 기준으로 판단하지만, 개발자는 **실제 데이터 특성**을 알기 때문에 더 나은 선택을 할 수 있다. 그래서 힌트가 필요하다.
