# 데이터베이스 인덱스와 ROWID 설명

## 1. 인덱스를 단순 포인터라고 설명하기 힘든 이유

인덱스는 단순 포인터가 아니라, 검색 구조와 RowID 가이드를 함께 가진 자료 구조이다.

* **계층적 구조**: B-Tree 등 인덱스는 루트 → 브랜치 → 리프 노드로 구성되어 있어 단순 포인터보다 복잡하다.
* **범위 검색 기능**: 인덱스는 범위 조건 조회가 가능하다.
* **메타데이터 포함**: 키 값, ROWID, 통계 정보 등 다양한 정보를 포함한다.

**비유 예시**: 책의 색인

* 키워드 → 페이지 번호
* 단순 포인터가 아니라, 검색과 위치 안내 기능을 모두 가진 구조

## 2. 인덱스가 ROWID를 찾는 이유

ROWID는 테이블 내 행의 물리적 위치를 나타내는 고유 식별자이다.

| 항목     | 설명                                 |
| ------ | ---------------------------------- |
| 직접 접근  | ROWID를 통해 테이블 블록의 정확한 위치로 바로 이동 가능 |
| 물리적 주소 | 파일 번호, 블록 번호, 슬롯 번호로 구성            |
| 고속 접근  | 디스크 I/O 최소화, 원하는 행에 직접 접근 가능       |
| 유일성    | 테이블 내에서 각 행마다 고유한 값                |

**예시 SQL**:

```sql
SELECT ROWID, empno, ename FROM emp;
```

* 결과: ROWID를 통해 특정 행을 바로 조회 가능

## 3. 대량 데이터 조회 시 인덱스 스캔이 풀 테이블 스캔보다 느린 이유

| 접근 방법         | 장점                                    | 단점                           | 추천 상황                              |
| ------------- | ------------------------------------- | ---------------------------- | ---------------------------------- |
| 풀 테이블 스캔(TFS) | 순차적 멀티블록 I/O, 캐시 효율 높음, 병렬 처리 가능      | 전체 테이블 읽음 → 불필요한 I/O 발생      | 전체 데이터 조회, 데이터 비율 5~15% 이상 조회 시 유리 |
| 인덱스 스캔(IFS)   | 필요한 데이터만 선택적 조회, 인덱스 커버링 시 테이블 접근 불필요 | RowID로 랜덤 I/O 발생, 대량 조회 시 느림 | 일부 데이터 조회, 커버링 인덱스 사용 시 유리         |

### 인덱스 스캔 과정 예시

1. 인덱스 읽기 → ROWID 획득
2. 테이블 블록 랜덤 접근 → 실제 데이터 읽기
3. 다음 인덱스 엔트리로 이동 → 반복

### 풀 테이블 스캔 과정 예시

1. 테이블 블록 순차 읽기
2. 여러 블록을 한 번에 읽어 디스크 헤드 이동 최소화
3. 캐시 활용으로 효율적 처리


### 성능 비교 기준

1. 인덱스 스캔이 유리한 경우: 전체 행의 1-5% 이하를 조회할 때
2. 풀 테이블 스캔이 유리한 경우: 전체 행의 10-15% 이상을 조회할 때
3. 회색 영역: 5-15% 사이에서는 데이터 분포, 클러스터링 팩터, 하드웨어 성능에 따라 최적의 접근 방식이 달라질 수 있음.


### 요약

1. 인덱스는 단순 포인터가 아니라, 검색 구조와 ROWID 가이드를 모두 포함한다.
2. 인덱스는 ROWID를 통해 테이블 데이터를 빠르게 조회하기 위해 존재한다.
3. 대량 데이터를 조회할 때는 랜덤 I/O 때문에 인덱스 스캔보다 풀 테이블 스캔이 더 효율적일 수 있다.
4. 일부 데이터만 조회하거나 커버링 인덱스를 사용할 때는 인덱스 스캔이 유리하다.
