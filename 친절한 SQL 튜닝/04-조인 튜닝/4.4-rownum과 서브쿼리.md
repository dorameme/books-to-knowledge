# rownum 과 서브쿼리 
---

## 1. 서브쿼리에서 ROWNUM이 문제되는 이유

서브쿼리 내부에 `ROWNUM`을 사용하면 옵티마이저는 **서브쿼리의 실행 순서와 결과 개수를 절대적으로 보존해야 한다.**

즉, 옵티마이저가 다음과 같은 최적화를 못한다.

* 조인 순서 변경
* 풀스캔 대신 인덱스 스캔으로 변경
* 필터 조건의 재배치
* 뷰 머징(View Merging)

서브쿼리의 ROWNUM은 **결과의 순서를 강제하는 pseudo-row**이기 때문에 옵티마이저가 이를 건드릴 수 없기 때문이다.

그래서 다음과 같은 구조가 대표적으로 문제를 일으킨다.

```sql
SELECT *
FROM (
    SELECT *
    FROM TABLE_A
    WHERE ...
    ORDER BY ...
)
WHERE ROWNUM = 1;
```

이 구조는 뷰 머징이 되지 않아 인덱스 기반 최적화가 막힌다.

---

## 2. 메인쿼리에서 ROWNUM은 왜 문제되지 않는가

메인쿼리에서 ROWNUM을 사용하는 경우는 상황이 다르다.

예:

```sql
SELECT *
FROM TABLE_A
WHERE ROWNUM <= 10;
```

여기서는 옵티마이저가 다음을 자유롭게 할 수 있다.

* 조인 순서 결정
* 인덱스 사용 결정
* 필요한 최소 row만 추출하기 위해 index range scan 사용

특히 Oracle 옵티마이저는 **"ROWNUM LIMIT 최적화"** 기능이 있다.
그래서 `ROWNUM <= n` 이면 가장 효율적인 액세스 경로를 선택하도록 설계되어 있다.

예:

```sql
SELECT *
FROM TABLE_A
ORDER BY CREATED_AT DESC
FETCH FIRST 1 ROWS ONLY;
```

이것과 동일한 구조로 처리하고, 인덱스가 있다면 **index max scan**을 사용하여 즉시 1건만 읽는다.

따라서 메인쿼리에서 ROWNUM 사용하는 것은 최적화에 방해가 되지 않는다.

---

## 3. 요약 표

| 위치                 | 옵티마이저 힌트/최적화 가능 여부 | 이유                            |
| ------------------ | ------------------ | ----------------------------- |
| **서브쿼리 내부 ROWNUM** | **제한됨**            | 서브쿼리 결과의 순서·건수 보존 필요. 뷰 머징 불가 |
| **메인쿼리의 ROWNUM**   | **문제 없음**          | 옵티마이저가 Limit 최적화를 적용 가능       |

---
아래는 **ROWNUM 사용 시 올바른 패턴과 잘못된 패턴**을 명확히 구분해 정리한 내용이다.
실무에서 가장 많이 헷갈리는 부분 위주로 정리한다.

---

# 1. 잘못 사용하는 패턴

### 잘못된 패턴 1: 서브쿼리에서 ORDER BY + ROWNUM

이 경우 옵티마이저가 서브쿼리를 **뷰 머징하지 못하고**, 인덱스 최적화를 적용하지 못한다.

```sql
SELECT *
FROM (
    SELECT *
    FROM EMP
    ORDER BY HIRE_DATE DESC
)
WHERE ROWNUM = 1;
```

문제점

* 내부 ORDER BY를 먼저 수행 후 ROWNUM을 적용해야 해서 최적화 불가
* 인덱스 `HIRE_DATE DESC`가 있어도 사용하지 못하고 FULL SORT 발생 가능

---

### 잘못된 패턴 2: 서브쿼리 WHERE 절에서 ROWNUM 필터링

```sql
SELECT *
FROM (
    SELECT *
    FROM EMP
    WHERE ROWNUM <= 10
) A
WHERE A.DEPTNO = 10;
```

문제점

* 먼저 10개를 뽑고 그중에서만 DEPTNO = 10을 다시 필터링 → 결과 왜곡
* 옵티마이저는 조인 순서, 조건 재배열 불가능

---

### 잘못된 패턴 3: 조인 전에 서브쿼리에서 ROWNUM을 걸어버림

```sql
SELECT *
FROM (
    SELECT *
    FROM EMP
    WHERE ROWNUM <= 5
) A
JOIN DEPT B ON A.DEPTNO = B.DEPTNO;
```

문제점

* 조인 최적화가 막히고, ROWNUM 때문에 EMP에서 임의의 5건만 가져오게 됨
* 의미적으로도 잘못된 결과

---

# 2. 올바르게 사용하는 패턴

## 올바른 패턴 1: 메인쿼리에 직접 ROWNUM 사용

```sql
SELECT *
FROM EMP
WHERE ROWNUM <= 10;
```

장점

* 옵티마이저가 가장 빠른 인덱스를 자동 선택
* 인덱스 없이도 빠른 TOP-N 최적화 적용

---

## 올바른 패턴 2: ORDER BY가 있을 때 FETCH FIRST 사용 (가장 권장)

```sql
SELECT *
FROM EMP
ORDER BY HIRE_DATE DESC
FETCH FIRST 1 ROWS ONLY;
```

장점

* Oracle이 공식적으로 TOP-N 최적화
* 인덱스 사용률 가장 좋음
* ROWNUM보다 옵티마이저가 더 잘 이해함

---

## 올바른 패턴 3: ROWNUM을 메인쿼리 WHERE 절에서만 제한

```sql
SELECT *
FROM (
    SELECT *
    FROM EMP
    ORDER BY HIRE_DATE DESC
)
WHERE ROWNUM <= 3;
```

이 패턴은 전통적으로 많이 쓰였고 **Oracle 12c 이상에서는 최적화 가능**
다만 FETCH FIRST가 더 명확하고 성능도 안정적이다.

---

# 3. 사용법 요약 정리표

| 구분                          | 적절 여부 | 이유                          |
| --------------------------- | ----- | --------------------------- |
| 메인쿼리 WHERE ROWNUM <= N      | 적절    | Limit 최적화 적용 가능             |
| 메인쿼리 ORDER BY + FETCH FIRST | 가장 적절 | 인덱스를 직접 활용한 TOP-N 최적화       |
| 서브쿼리에서 ROWNUM 필터링           | 부적절   | 조건 재배열·뷰 머징 불가              |
| 서브쿼리에서 ORDER BY 후 ROWNUM    | 부적절   | 인덱스 기반 최적화 불가, FULL SORT 발생 |

---

## 4. 결론

* **서브쿼리에 ROWNUM이 있으면 최적화가 제한되는 것이 맞다.**
* **메인쿼리의 ROWNUM은 최적화를 방해하지 않는다.**

