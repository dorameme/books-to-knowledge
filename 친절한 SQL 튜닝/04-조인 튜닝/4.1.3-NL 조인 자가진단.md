# 조인 조건 순서와 인덱스 활용

## 핵심: 조건 순서 자체가 문제가 아니다

먼저 명확히 해야 할 점:

```sql
a.STRD_GRP_ID = b.STRD_GRP_ID  -- 첫 번째
b.STRD_GRP_ID = a.STRD_GRP_ID  -- 두 번째
```

**논리적으로 완전히 동일하다.** 최신 옵티마이저는 둘을 똑같이 처리한다.

## 그렇다면 왜 바꾸는가?

책에서 강조하는 것은 "인덱스 컬럼이 조인 조건의 왼쪽에 오도록 작성하는 습관"이다.

### 상황 가정

ODM_TRMS 테이블(b)에 다음 인덱스가 있다고 가정한다:

```sql
CREATE INDEX IDX_ODM_TRMS ON ODM_TRMS(STRD_GRP_ID, STRD_ID);
```

### NL 조인 실행 시나리오

```
FOR a 테이블의 각 행
    b 테이블에서 매칭되는 행 찾기
    → b.STRD_GRP_ID = ? AND b.STRD_ID = ? 로 인덱스 검색
```

### 개선된 쿼리의 의도

```sql
WHERE b.STRD_GRP_ID = a.STRD_GRP_ID  -- Inner 테이블(b)을 왼쪽에
  AND b.STRD_ID = a.STRD_ID          -- Inner 테이블(b)을 왼쪽에
```

**의도: "이 조건은 b 테이블의 인덱스를 사용해야 한다"를 명확히 표현한다**

## 실제로 차이가 나는 경우

### 1. 오래된 DBMS (Oracle 9i 이전 등)

일부 오래된 옵티마이저는 조건 순서에 영향을 받았다.

```sql
-- 비효율적으로 해석될 수 있음 (옛날 방식)
a.STRD_GRP_ID = b.STRD_GRP_ID
→ "a 테이블의 인덱스를 사용해야 하나?"

-- 명확하게 해석됨
b.STRD_GRP_ID = a.STRD_GRP_ID
→ "b 테이블의 인덱스를 사용하자"
```

### 2. 힌트나 실행계획 강제 시

```sql
SELECT /*+ USE_NL(a b) INDEX(b IDX_ODM_TRMS) */ *
FROM PRA_HST_STC a, ODM_TRMS b
WHERE b.STRD_GRP_ID = a.STRD_GRP_ID  -- 인덱스 대상 테이블을 왼쪽에
```

힌트와 조건 작성 방향이 일치하면 의도가 더 명확하다.

### 3. 개발자의 가독성과 의도 전달

```sql
-- 첫 번째: 어느 테이블 인덱스를 쓸지 불명확
a.STRD_GRP_ID = b.STRD_GRP_ID

-- 두 번째: "b 테이블 인덱스를 써라"는 의도 명확
b.STRD_GRP_ID = a.STRD_GRP_ID
```

## 책의 진짜 메시지

책에서 강조하는 것은:

> "제대로 아는 개발자라면 Inner 테이블(반복 접근되는 테이블)의 인덱스를 먼저 생각해야 한다"

### 개발 현장의 문제

```sql
-- 현실: 개발자가 아무 생각 없이 작성
WHERE a.STRD_GRP_ID = b.STRD_GRP_ID
  AND a.STRD_ID = b.STRD_ID

-- 결과: b 테이블에 인덱스가 필요하다는 것을 인지 못함
-- DBA가 a 테이블에만 인덱스 생성
-- 성능 저하 발생
```

### 올바른 접근

```sql
-- 개선: Inner 테이블을 왼쪽에 배치
WHERE b.STRD_GRP_ID = a.STRD_GRP_ID  -- "b의 인덱스가 필요해!"
  AND b.STRD_ID = a.STRD_ID

-- 이렇게 작성하면:
-- 1. 코드 리뷰어가 "b에 인덱스 있나?" 물어본다
-- 2. DBA가 b 테이블 인덱스 필요성을 인지한다
-- 3. 성능 튜닝 시 어디를 봐야 할지 명확하다
```

## 최신 DBMS에서는?

Oracle 11g 이상, PostgreSQL, MySQL 최신 버전 등에서는 조건 순서와 무관하게 최적화한다.

하지만:

1. **코드 가독성**: Inner 테이블 인덱스 필요성을 명시한다
2. **유지보수성**: 나중에 보는 사람이 의도를 파악하기 쉽다
3. **방어적 코딩**: 혹시 모를 옵티마이저 버그나 버전 차이에 대비한다

## 결론

조건 순서를 바꾸는 것 자체가 성능 개선이 아니라, "Inner 테이블 인덱스를 의식하고 작성하라"는 코딩 습관을 강조하는 것이다.

```sql
-- 나쁜 습관 (무의식적 작성)
WHERE a.COL = b.COL

-- 좋은 습관 (의식적 작성)
WHERE b.COL = a.COL  -- "b에 인덱스 필요!"
```



##  둘 다 인덱스가 있을 수 있다

```sql
-- 둘 다 인덱스가 있는 상황
PRA_HST_STC(a): INDEX on (STRD_GRP_ID, STRD_ID)  -- Outer 테이블
ODM_TRMS(b):    INDEX on (STRD_GRP_ID, STRD_ID)  -- Inner 테이블
```

이 경우 조건 순서는 **정말로 의미가 없다**.

## 그렇다면 왜 Inner 테이블을 왼쪽에?

핵심은 **"어느 쪽 인덱스가 더 중요한가?"** 이다.

### NL 조인에서의 실행 횟수 차이

```sql
-- 실행 계획: PRA_HST_STC(a) → ODM_TRMS(b) NL 조인
-- a 테이블: 100건
-- b 테이블: 10,000건

Outer 테이블(a)의 인덱스 사용:
  - WHERE a.SALE_ORG_ID = :sale_org_id
  - 1번만 실행 (초기 필터링)
  
Inner 테이블(b)의 인덱스 사용:
  - WHERE b.STRD_GRP_ID = ? AND b.STRD_ID = ?
  - 100번 실행 (각 a 행마다 반복)
```

**결론: Inner 테이블 인덱스가 100배 더 많이 사용된다!**

### 우선순위가 다르다

```sql
중요도 순서:
1. Inner 테이블 인덱스 (반복 사용) ← 가장 중요!
2. Outer 테이블 인덱스 (1회 사용)
```

## 실전 시나리오

### 시나리오 1: 인덱스 생성 예산이 제한적

```sql
-- DBA: "인덱스 하나만 만들 수 있어요"
-- 개발자: ???

-- 답: Inner 테이블 인덱스를 만들어라!
CREATE INDEX IDX_ODM_TRMS ON ODM_TRMS(STRD_GRP_ID, STRD_ID);

-- 이유: 100번 사용되므로 효과가 100배!
```

### 시나리오 2: 성능 튜닝 시

```sql
-- 성능 문제 발생!
-- 어느 인덱스를 먼저 확인할까?

-- 정답: Inner 테이블 인덱스부터!
-- 왜? 반복 실행되므로 영향이 크다
```

### 시나리오 3: 코드 리뷰

```sql
-- Case A: 의도가 불명확
WHERE a.STRD_GRP_ID = b.STRD_GRP_ID

-- 리뷰어: "이거... a 인덱스? b 인덱스? 뭘 써야 하지?"


-- Case B: 의도가 명확
WHERE b.STRD_GRP_ID = a.STRD_GRP_ID  -- Inner 테이블 명시!

-- 리뷰어: "아, b에 인덱스 필요하구나. 확인해보자"
```

## 책의 진짜 의도

책에서 강조하는 것은:

> "개발자가 **Inner 테이블 인덱스의 중요성을 인식**하고 코딩하라"

### 현실의 문제

```sql
-- 현실 1: 개발자가 무의식적으로 작성
WHERE a.COL = b.COL

-- 현실 2: DBA가 양쪽 다 인덱스 생성
-- 결과: 불필요한 인덱스 증가, 관리 부담


-- 올바른 접근:
WHERE b.COL = a.COL  -- "b가 Inner니까 b 인덱스가 중요해!"

-- 결과:
-- 1. 개발자: b 인덱스 필요성 인지
-- 2. DBA: b 인덱스만 생성 (a는 필요시만)
-- 3. 유지보수자: 의도 파악 쉬움
```

## 정리: 왼쪽에 쓰는 진짜 이유

1. **우선순위 표현**: Inner 테이블이 더 중요함을 명시
2. **코드 가독성**: "이 테이블 인덱스를 사용해야 함"
3. **의사소통**: 코드 리뷰, DBA와의 협업에서 명확함
4. **방어적 코딩**: 혹시 모를 옵티마이저 오류 대비

## 예외: 둘 다 인덱스가 필요한 경우

```sql
-- 양쪽 다 인덱스가 진짜 필요하다면?
WHERE b.STRD_GRP_ID = a.STRD_GRP_ID  -- b 인덱스 (더 중요)
  AND b.STRD_ID = a.STRD_ID

-- 주석으로 명시
-- a 테이블 인덱스: (SALE_ORG_ID, STRD_GRP_ID, STRD_ID)
-- b 테이블 인덱스: (STRD_GRP_ID, STRD_ID) ← 더 중요!
```

결국 **"Inner 테이블 인덱스가 더 중요하므로, 코드에서도 이를 강조하자"**는 것이 핵심.
