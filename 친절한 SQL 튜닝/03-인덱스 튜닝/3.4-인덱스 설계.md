# IN 조건과 =의 차이, 인덱스와 ORDER BY 최적화 안내

## 핵심 요약

* `=`는 단일 값 비교이다. 인덱스를 한 번 탐색하면 된다.
* `IN`은 여러 값 비교이다. 인덱스를 값마다 여러 번 탐색할 수 있다.
* 인덱스를 여러 번 탐색하면 결과를 합치는 과정에서 인덱스의 전체 정렬 순서가 깨진다.
* `ORDER BY` 최적화를 원하면, 인덱스는 `ORDER BY` 컬럼을 선두로 두고 `IN` 컬럼은 뒤쪽에 두어 필터로 적용해야 한다.

---

## 개념 설명 (초간단)

1. `col = 10`

   * 인덱스에서 `col = 10` 구간을 한 번 읽는다.
   * 읽는 순서는 인덱스 정렬 순서와 동일하다.
   * 따라서 `ORDER BY`가 인덱스 순서와 같다면 SORT가 필요 없다.

2. `col IN (10, 20, 30)`

   * 옵티마이저는 보통 각 값에 대해 인덱스 구간을 각각 스캔한다.
   * 예: `col = 10` 스캔 → `col = 20` 스캔 → `col = 30` 스캔
   * 각 구간 내부는 정렬되어 있으나, 구간들을 합치면 전체 결과는 정렬되어 있지 않다.
   * 따라서 `ORDER BY`가 있으면 추가 SORT가 필요할 수 있다.

---

## 처리 방식 두 가지(간단한 이름)

### A. IN-List Iterator (인덱스 액세스 방식)

* 동작: IN 리스트의 각 값을 인덱스로 개별 스캔한다.
* 결과: 각 스캔의 결과를 합치므로 전체 순서가 보장되지 않는다.
* 단점: `ORDER BY` 시 SORT가 발생할 가능성이 높다.

### B. Filter 방식

* 동작: 인덱스는 `ORDER BY` 기준으로 순차 스캔하고, IN 조건은 읽은 결과에 대해 필터로 적용한다.
* 결과: 인덱스 순서를 그대로 유지하므로 추가 SORT가 불필요하다.
* 장점: `ORDER BY` 최적화에 유리하다.

---

## 예시 SQL과 인덱스 구성

테이블: `orders(order_date, status, id, amount)`

### 상황 1 (비효율적 구성)

```sql
-- 쿼리
SELECT *
FROM orders
WHERE status IN ('A','B','C')
ORDER BY order_date;

-- 인덱스
CREATE INDEX idx_status_orderdate ON orders(status, order_date);
```

* 인덱스가 `(status, order_date)` 이므로 옵티마이저는 `status`별로 접근하려 한다.
* IN-List Iterator 방식으로 `status='A'`, `status='B'`, `status='C'`를 각각 스캔할 가능성이 크다.
* 스캔 결과를 합치면 `order_date`로 정렬된 전체 결과가 되지 않을 수 있다.
* 따라서 SORT 연산이 발생한다.

### 상황 2 (권장 구성)

```sql
-- 쿼리
SELECT *
FROM orders
WHERE status IN ('A','B','C')
ORDER BY order_date;

-- 인덱스
CREATE INDEX idx_orderdate_status ON orders(order_date, status);
```

* 인덱스가 `(order_date, status)` 이므로 인덱스를 `order_date` 순으로 순차 스캔할 수 있다.
* `status IN (...)` 조건은 읽은 행에 대해 필터로 적용한다.
* 읽는 순서가 이미 `order_date` 기준이므로 추가 SORT가 필요 없다.

---

## 표: 처리 방식 비교

| 항목                 | IN-List Iterator (인덱스 액세스) | Filter 방식           |
| ------------------ | -------------------------- | ------------------- |
| 인덱스 사용 기준          | IN 컬럼을 선두로 사용              | ORDER BY 컬럼을 선두로 사용 |
| 인덱스 스캔 횟수          | 값 갯수 만큼 여러 번               | 한 번(순차 스캔)          |
| 전체 결과의 정렬 보장       | 불확실(정렬 깨짐)                 | 보장(인덱스 순서 유지)       |
| ORDER BY 시 추가 SORT | 발생 가능성 높음                  | 보통 불필요              |

---

## 실행계획(EXPLAIN)에서 확인할 포인트

* **index condition** 또는 **index range scan** 관련 항목 확인한다. IN 값 각각에 대한 접근이 보이면 IN-List Iterator일 가능성이 크다.
* **Using index condition** 대신 **Using where**(혹은 filter 관련 표시)로 인덱스가 순차 스캔되고 필터가 적용되는지 확인한다.
* **Sort** 또는 **Filesort**가 표시되면 추가 정렬이 발생한다는 뜻이다.

---

## 실무 팁

1. ORDER BY가 중요한 쿼리는 인덱스를 먼저 `ORDER BY` 컬럼으로 만들고, IN 컬럼은 뒤에 둔다.
2. IN 값이 많으면 IN-List Iterator 비용이 크게 증가한다. 값 개수를 줄이거나 다른 조건으로 바꾸는 것을 고려한다.
3. 실행계획(EXPLAIN)을 항상 확인한다. 의도대로 인덱스가 사용되는지, Filesort가 발생하는지를 본다.
4. 복합 인덱스를 설계할 때 쿼리의 WHERE, ORDER BY, GROUP BY 패턴을 함께 고려한다.

---

## 간단한 그림(텍스트)

잘못된 접근 (IN-List Iterator):

```
index: (status, order_date)
scan: status='A' -> status='C' -> status='B'  (옵티마이저 순서)
merge -> 결과 정렬 안됨 -> SORT 필요
```

올바른 접근 (Filter 방식):

```
index: (order_date, status)
scan: order_date 오름차순으로 순차 읽기
filter: status IN ('A','B','C') 적용
결과: 이미 정렬된 상태 -> SORT 불필요
```
